#include <incompressibleAlphatJayatillekeWallFunctionFvPatchScalarField.hxx>

#include <turbulenceModel.hxx>
#include <addToRunTimeSelectionTable.hxx>

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

namespace tnbLib
{
	namespace incompressible
	{

		// * * * * * * * * * * * * * * Static Data Members * * * * * * * * * * * * * //

		scalar alphatJayatillekeWallFunctionFvPatchScalarField::tolerance_ = 0.01;
		label alphatJayatillekeWallFunctionFvPatchScalarField::maxIters_ = 10;

		// * * * * * * * * * * * * Protected Member Functions  * * * * * * * * * * * //

		scalar alphatJayatillekeWallFunctionFvPatchScalarField::Psmooth
		(
			const scalar Prat
		) const
		{
			return 9.24*(pow(Prat, 0.75) - 1.0)*(1.0 + 0.28*exp(-0.007*Prat));
		}


		scalar alphatJayatillekeWallFunctionFvPatchScalarField::yPlusTherm
		(
			const nutWallFunctionFvPatchScalarField& nutw,
			const scalar P,
			const scalar Prat
		) const
		{
			scalar ypt = 11.0;

			for (int i = 0; i < maxIters_; i++)
			{
				scalar f = ypt - (log(nutw.E()*ypt) / nutw.kappa() + P) / Prat;
				scalar df = 1.0 - 1.0 / (ypt*nutw.kappa()*Prat);
				scalar yptNew = ypt - f / df;

				if (yptNew < vSmall)
				{
					return 0;
				}
				else if (mag(yptNew - ypt) < tolerance_)
				{
					return yptNew;
				}
				else
				{
					ypt = yptNew;
				}
			}

			return ypt;
		}


		// * * * * * * * * * * * * * * * * Constructors  * * * * * * * * * * * * * * //

		alphatJayatillekeWallFunctionFvPatchScalarField::
			alphatJayatillekeWallFunctionFvPatchScalarField
			(
				const fvPatch& p,
				const DimensionedField<scalar, volMesh>& iF
			)
			:
			fixedValueFvPatchScalarField(p, iF),
			Prt_(0.85)
		{}


		alphatJayatillekeWallFunctionFvPatchScalarField::
			alphatJayatillekeWallFunctionFvPatchScalarField
			(
				const alphatJayatillekeWallFunctionFvPatchScalarField& ptf,
				const fvPatch& p,
				const DimensionedField<scalar, volMesh>& iF,
				const fvPatchFieldMapper& mapper
			)
			:
			fixedValueFvPatchScalarField(ptf, p, iF, mapper),
			Prt_(ptf.Prt_)
		{}


		alphatJayatillekeWallFunctionFvPatchScalarField::
			alphatJayatillekeWallFunctionFvPatchScalarField
			(
				const fvPatch& p,
				const DimensionedField<scalar, volMesh>& iF,
				const dictionary& dict
			)
			:
			fixedValueFvPatchScalarField(p, iF, dict),
			Prt_(readScalar(dict.lookup("Prt")))  // force read to avoid ambiguity
		{}


		alphatJayatillekeWallFunctionFvPatchScalarField::
			alphatJayatillekeWallFunctionFvPatchScalarField
			(
				const alphatJayatillekeWallFunctionFvPatchScalarField& wfpsf
			)
			:
			fixedValueFvPatchScalarField(wfpsf),
			Prt_(wfpsf.Prt_)
		{}


		alphatJayatillekeWallFunctionFvPatchScalarField::
			alphatJayatillekeWallFunctionFvPatchScalarField
			(
				const alphatJayatillekeWallFunctionFvPatchScalarField& wfpsf,
				const DimensionedField<scalar, volMesh>& iF
			)
			:
			fixedValueFvPatchScalarField(wfpsf, iF),
			Prt_(wfpsf.Prt_)
		{}


		// * * * * * * * * * * * * * * * Member Functions  * * * * * * * * * * * * * //

		void alphatJayatillekeWallFunctionFvPatchScalarField::updateCoeffs()
		{
			if (updated())
			{
				return;
			}

			const label patchi = patch().index();

			// Retrieve turbulence properties from model

			const turbulenceModel& turbModel = db().lookupObject<turbulenceModel>
				(
					IOobject::groupName
					(
						turbulenceModel::propertiesName,
						internalField().group()
					)
					);

			const nutWallFunctionFvPatchScalarField& nutw =
				nutWallFunctionFvPatchScalarField::nutw(turbModel, patchi);

			const scalar Cmu25 = pow(nutw.Cmu(), 0.25);
			const scalarField& y = turbModel.y()[patchi];
			const tmp<volScalarField> tnu = turbModel.nu();
			const volScalarField& nu = tnu();
			const scalarField& nuw = nu.boundaryField()[patchi];
			const tmp<volScalarField> tk = turbModel.k();
			const volScalarField& k = tk();

			const IOdictionary& transportProperties =
				db().lookupObject<IOdictionary>("transportProperties");

			// Molecular Prandtl number
			const scalar Pr
			(
				dimensionedScalar
				(
					"Pr",
					dimless,
					transportProperties.lookup("Pr")
				).value()
			);

			// Populate boundary values
			scalarField& alphatw = *this;
			forAll(alphatw, facei)
			{
				const label celli = patch().faceCells()[facei];

				const scalar yPlus = Cmu25 * sqrt(k[celli])*y[facei] / nuw[facei];

				// Molecular-to-turbulent Prandtl number ratio
				const scalar Prat = Pr / Prt_;

				// Thermal sublayer thickness
				const scalar P = Psmooth(Prat);
				const scalar yPlusTherm = this->yPlusTherm(nutw, P, Prat);

				// Update turbulent thermal conductivity
				if (yPlus > yPlusTherm)
				{
					const scalar nu = nuw[facei];
					const scalar kt =
						nu * (yPlus / (Prt_*(log(nutw.E()*yPlus) / nutw.kappa() + P)) - 1 / Pr);

					alphatw[facei] = max(0.0, kt);
				}
				else
				{
					alphatw[facei] = 0.0;
				}
			}

			fixedValueFvPatchField<scalar>::updateCoeffs();
		}


		void alphatJayatillekeWallFunctionFvPatchScalarField::write(Ostream& os) const
		{
			fvPatchField<scalar>::write(os);
			writeEntry(os, "Prt", Prt_);
			writeEntry(os, "value", *this);
		}


		// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

		makePatchTypeField
		(
			fvPatchScalarField,
			alphatJayatillekeWallFunctionFvPatchScalarField
		);

		// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

	} // End namespace incompressible
} // End namespace tnbLib

// ************************************************************************* //